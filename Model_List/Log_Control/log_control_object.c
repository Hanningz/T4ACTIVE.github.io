/**
 * Generated by anjay_codegen.py on 2017-10-17 15:47:49
 *
 * LwM2M Object: Log Control
 * ID: 25011, URN: urn:oma:lwm2m:x:25011:1, Optional, Multiple
 *
 * Controls logging sensor data to filesystem.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/defs.h>
#include <avsystem/commons/list.h>

/**
 * LogClass: R, Multiple, Mandatory
 * type: integer, range: 0-255, unit: N/A
 * Part of the Logging Event Set: 1/5 (Must be a Single-Instance Resource) Define the Log Event Class: 0: generic (default) 1: system 2: security 3: event 4: trace 5: panic 6: charging [7-99]: reserved [100-255]: vendor specific
 */
#define RID_LOGCLASS 4010

/**
 * LogStart: E, Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * Part of the Logging Event Set: 2/5 Actions: a) Start data collection(DC) b) LogStatus is set to 0 (running) c) DC is emptied(default) or extended according to arg'0' value d) DC Period is set according to arg'1' value Arguments '0': DC emptied(=0[default] or extended(=1) '1': set the DC Period (in sec): if=0 or absent[default] DC is stopped by LogStop action only.
 */
#define RID_LOGSTART 4011

/**
 * LogStop: E, Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * Log Event Set Interface 3/5 Actions: a) Stop data collection(DC) b) LogStatus is set to 1 (stopped) c) DC is kept(default) or emptied according to arg'0' value Argument: '0': DC kept(=0)[default]or emptied(=1)
 */
#define RID_LOGSTOP 4012

/**
 * LogStatus: R, Multiple, Mandatory
 * type: integer, range: 0-255, unit: N/A
 * Log Event Set Interface 4/5 (Must be a Single-Instance Resource) Data Collection process status: 0 : running 1 : stopped [2-99] : reserved [100-255] : vendor specific.
 */
#define RID_LOGSTATUS 4013

/**
 * LogData: R, Multiple, Mandatory
 * type: opaque, range: N/A, unit: N/A
 * Log Event Set Interface 5/5 (May be a Multiple-Instance Resource) Read Access on that Resource returns the Data Collection associated to the current Object Instance. Data format followed by this Opaque Resource is given by the 1st byte of the opaque sequence: 0 : OMA-LwM2M TLV format 1 : OMA-LwM2M JSON format 2 : OMA-LwM2M CBOR format [3..99] reserved [100..255] vendor specific
 */
#define RID_LOGDATA 4014

/**
 * LogFile: R, Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * Sets the filename logs are saved into."
 */
#define RID_LOGFILE 20180

typedef struct log_control_instance_struct {
    anjay_iid_t iid;

    // TODO: instance state
} log_control_instance_t;

typedef struct log_control_struct {
    const anjay_dm_object_def_t *def;
    AVS_LIST(log_control_instance_t) instances;

    // TODO: object state
} log_control_t;

static inline log_control_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, log_control_t, def);
}

static log_control_instance_t *
find_instance(const log_control_t *obj,
              anjay_iid_t iid) {
    AVS_LIST(log_control_instance_t) it;
    AVS_LIST_FOREACH(it, obj->instances) {
        if (it->iid == iid) {
            return it;
        } else if (it->iid > iid) {
            break;
        }
    }

    return NULL;
}

static int instance_present(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid) {
    (void)anjay;
    return find_instance(get_obj(obj_ptr), iid) != NULL;
}

static int instance_it(anjay_t *anjay,
                       const anjay_dm_object_def_t *const *obj_ptr,
                       anjay_iid_t *out,
                       void **cookie) {
    (void)anjay;

    AVS_LIST(log_control_instance_t) curr = (AVS_LIST(log_control_instance_t))*cookie;
    if (!curr) {
        curr = get_obj(obj_ptr)->instances;
    } else {
        curr = AVS_LIST_NEXT(curr);
    }

    *out = curr ? curr->iid : ANJAY_IID_INVALID;
    *cookie = curr;
    return 0;
}

static anjay_iid_t get_new_iid(AVS_LIST(log_control_instance_t) instances) {
    anjay_iid_t iid = 1;
    AVS_LIST(log_control_instance_t) it;
    AVS_LIST_FOREACH(it, instances) {
        if (it->iid == iid) {
            ++iid;
        } else if (it->iid > iid) {
            break;
        }
    }
    return iid;
}

static int init_instance(log_control_instance_t *inst,
                         anjay_iid_t iid) {
    assert(iid != ANJAY_IID_INVALID);

    inst->iid = iid;
    // TODO: instance init

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static void release_instance(log_control_instance_t *inst) {
    // TODO: instance cleanup
    (void) inst;
}

static int instance_create(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t *inout_iid,
                           anjay_ssid_t ssid) {
    (void) anjay; (void) ssid;
    log_control_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(log_control_instance_t) created = AVS_LIST_NEW_ELEMENT(log_control_instance_t);
    if (!created) {
        return ANJAY_ERR_INTERNAL;
    }

    if (*inout_iid == ANJAY_IID_INVALID) {
        *inout_iid = get_new_iid(obj->instances);
    }

    int result = ANJAY_ERR_INTERNAL;
    if (*inout_iid == ANJAY_IID_INVALID
            || (result == init_instance(created, *inout_iid))) {
        AVS_LIST_CLEAR(&created);
        return result;
    }

    AVS_LIST(log_control_instance_t) *ptr;
    AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
        if ((*ptr)->iid > created->iid) {
            break;
        }
    }

    AVS_LIST_INSERT(ptr, created);
    return 0;
}

static int instance_remove(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void)anjay;
    log_control_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(log_control_instance_t) *it;
    AVS_LIST_FOREACH_PTR(it, &obj->instances) {
        if ((*it)->iid == iid) {
            release_instance(*it);
            AVS_LIST_DELETE(it);
            return 0;
        } else if ((*it)->iid > iid) {
            break;
        }
    }

    assert(0);
    return ANJAY_ERR_NOT_FOUND;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    log_control_instance_t *inst = find_instance(get_obj(obj_ptr), iid);
    assert(inst);

    // TODO: instance reset
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_output_ctx_t *ctx) {
    (void)anjay;

    log_control_t *obj = get_obj(obj_ptr);
    assert(obj);
    log_control_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_LOGCLASS:
        {
            anjay_output_ctx_t *array = anjay_ret_array_start(ctx);
            int result = 0;
            if (!array
                    || (result = anjay_ret_array_index(array, 0))
                    || (result = anjay_ret_i32(array, 0))) {
                return result ? result : ANJAY_ERR_INTERNAL;
            }
            return anjay_ret_array_finish(array);
        }

    case RID_LOGSTATUS:
        {
            anjay_output_ctx_t *array = anjay_ret_array_start(ctx);
            int result = 0;
            if (!array
                    || (result = anjay_ret_array_index(array, 0))
                    || (result = anjay_ret_i32(array, 0))) {
                return result ? result : ANJAY_ERR_INTERNAL;
            }
            return anjay_ret_array_finish(array);
        }

    case RID_LOGDATA:
        {
            anjay_output_ctx_t *array = anjay_ret_array_start(ctx);
            int result = 0;
            if (!array
                    || (result = anjay_ret_array_index(array, 0))
                    || (result = anjay_ret_bytes(array, "", 0))) {
                return result ? result : ANJAY_ERR_INTERNAL;
            }
            return anjay_ret_array_finish(array);
        }

    case RID_LOGFILE:
        {
            anjay_output_ctx_t *array = anjay_ret_array_start(ctx);
            int result = 0;
            if (!array
                    || (result = anjay_ret_array_index(array, 0))
                    || (result = anjay_ret_string(array, ""))) {
                return result ? result : ANJAY_ERR_INTERNAL;
            }
            return anjay_ret_array_finish(array);
        }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void)arg_ctx;

    log_control_t *obj = get_obj(obj_ptr);
    assert(obj);
    log_control_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_LOGSTART:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    case RID_LOGSTOP:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_dim(anjay_t *anjay,
                        const anjay_dm_object_def_t *const *obj_ptr,
                        anjay_iid_t iid,
                        anjay_rid_t rid) {
    (void) anjay;

    log_control_t *obj = get_obj(obj_ptr);
    assert(obj);
    log_control_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_LOGCLASS:
        return 1; // TODO

    case RID_LOGSTART:
        return 1; // TODO

    case RID_LOGSTOP:
        return 1; // TODO

    case RID_LOGSTATUS:
        return 1; // TODO

    case RID_LOGDATA:
        return 1; // TODO

    case RID_LOGFILE:
        return 1; // TODO

    default:
        return ANJAY_DM_DIM_INVALID;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 25011,
    .supported_rids = ANJAY_DM_SUPPORTED_RIDS(
                RID_LOGCLASS,
                RID_LOGSTART,
                RID_LOGSTOP,
                RID_LOGSTATUS,
                RID_LOGDATA,
                RID_LOGFILE,
            ),
    .handlers = {
        .instance_it = instance_it,
        .instance_present = instance_present,
        .instance_create = instance_create,
        .instance_remove = instance_remove,
        .instance_reset = instance_reset,

        .resource_present = anjay_dm_resource_present_TRUE,
        .resource_read = resource_read,
        .resource_execute = resource_execute,
        .resource_dim = resource_dim,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP,
    }
};

const anjay_dm_object_def_t **log_control_object_create(void) {
    log_control_t *obj = (log_control_t *)
            calloc(1, sizeof(log_control_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void log_control_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        log_control_t *obj = get_obj(def);
        AVS_LIST_CLEAR(&obj->instances) {
            release_instance(obj->instances);
        }

        // TODO: object cleanup

        free(obj);
    }
}
